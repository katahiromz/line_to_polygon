<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>line_to_polygon</title>
</head>
<body>
    <h1>線からポリゴンへ</h1>

    <canvas id="my-canvas" width="300" height="300"></canvas>

    <form>
        <label for="my-radio-0">
            <input type="radio" id="my-radio-0" name="my-radio" value="line"> 線
        </label>
        <label for="my-radio-1">
            <input type="radio" id="my-radio-1" name="my-radio" value="polygon" checked> ポリゴン
        </label>
    </form>

    <script>
        let canvas = document.getElementById('my-canvas');
        let radios = document.getElementsByName('my-radio');
        let ctx = canvas.getContext('2d', { alpha: false });
        let anime = null; // アニメーション
        let time = (new Date()).getTime(); // 処理フレームの時刻。
        let px0 = 0, py0 = 5, px1 = 50, py1 = 50; // 線の位置
        let vx0 = 30, vy0 = -80, vx1 = 80, vy1 = -20; // 線の頂点の速度

        /**
         * 指定された2点間に直線を描画する。
         * この関数は、描画スタイル（色や太さ）の設定は行わず、パスの定義と実行のみを行う。
         * * @param {CanvasRenderingContext2D} ctx - 描画に使用するCanvas 2Dコンテキスト。
         * @param {number} x0 - 始点 (P0) のX座標。
         * @param {number} y0 - 始点 (P0) のY座標。
         * @param {number} x1 - 終点 (P1) のX座標。
         * @param {number} y1 - 終点 (P1) のY座標。
         */
        const drawLine = (ctx, x0, y0, x1, y1) => {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        };

        /**
         * 2点間に幅を持った線（矩形ポリゴン）を描画する。
         * これは、Canvasの標準的な ctx.stroke() による描画ではなく、
         * 線の幅に基づいて計算された4つの頂点を持つ多角形を ctx.fill() で塗りつぶす手法。
         * * @param {CanvasRenderingContext2D} ctx - 描画に使用するCanvas 2Dコンテキスト。lineWidth, strokeStyleが適用される。
         * @param {number} x0 - 始点 (P0) のX座標。
         * @param {number} y0 - 始点 (P0) のY座標。
         * @param {number} x1 - 終点 (P1) のX座標。
         * @param {number} y1 - 終点 (P1) のY座標。
         * @param {boolean} [debugging=false] - trueの場合、計算された4つの頂点を黄色の点で描画する。
         */
        const drawLineByPolygon = (ctx, x0, y0, x1, y1, debugging = false) => {
            const lineWidth = ctx.lineWidth;
            const halfWidth = lineWidth / 2;
            // 1. 方向ベクトルの計算
            const dx = x1 - x0, dy = y1 - y0;
            // 2. 法線ベクトルの計算 (時計回りに90度回転)
            const nx = dy, ny = -dx;
            // 法線ベクトルを正規化（長さ1にする）
            const len = Math.sqrt(nx * nx + ny * ny);
            const normX = nx / len, normY = ny / len;
            // 3. 矩形の4つの頂点を計算
            // 始点P1から法線方向に +/- halfWidth オフセット
            const p0x = x0 + normX * halfWidth;
            const p0y = y0 + normY * halfWidth;
            const p1x = x0 - normX * halfWidth;
            const p1y = y0 - normY * halfWidth;
            // 終点P2から法線方向に +/- halfWidth オフセット
            const p2x = x1 - normX * halfWidth;
            const p2y = y1 - normY * halfWidth;
            const p3x = x1 + normX * halfWidth;
            const p3y = y1 + normY * halfWidth;
            // 4. 矩形の塗りつぶし
            // 頂点を結んで多角形を作成
            ctx.beginPath();
            ctx.moveTo(p0x, p0y);
            ctx.lineTo(p1x, p1y);
            ctx.lineTo(p2x, p2y);
            ctx.lineTo(p3x, p3y);
            ctx.closePath();
            ctx.fillStyle = ctx.strokeStyle;
            ctx.fill();

            if (debugging) {
                // 黄色い頂点を描く(デバッグ用)
                ctx.fillStyle = "yellow";
                let radius = 3;
                ctx.beginPath();
                ctx.arc(p0x, p0y, radius, 0, 2 * Math.PI, false);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(p1x, p1y, radius, 0, 2 * Math.PI, false);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(p2x, p2y, radius, 0, 2 * Math.PI, false);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(p3x, p3y, radius, 0, 2 * Math.PI, false);
                ctx.fill();
            }
        };

        // 描画する関数
        const render = () => {
            // キャンバスのサイズ
            let width = canvas.width, height = canvas.height;
            // 経過時間を計算
            let new_time = (new Date()).getTime();
            let diff_time = (new_time - time) / 1000.0; // 秒単位
            time = new_time; // 時刻を更新

            // 黒で塗りつぶす
            ctx.clearRect(0, 0, width, height);

            // 線の位置を動かす
            px0 += vx0 * diff_time;
            py0 += vy0 * diff_time;
            px1 += vx1 * diff_time;
            py1 += vy1 * diff_time;

            // カベに当たったら跳ね返る
            if (px0 < 0) { px0 = 0; vx0 = -vx0; }
            if (px1 < 0) { px1 = 0; vx1 = -vx1; }
            if (py0 < 0) { py0 = 0; vy0 = -vy0; }
            if (py1 < 0) { py1 = 0; vy1 = -vy1; }
            if (px0 > width) { px0 = width; vx0 = -vx0; }
            if (px1 > width) { px1 = width; vx1 = -vx1; }
            if (py0 > height) { py0 = height; vy0 = -vy0; }
            if (py1 > height) { py1 = height; vy1 = -vy1; }

            // 線を描く
            ctx.lineWidth = 20;
            console.assert(radios.length == 2);
            const is_polygon = radios[1].checked;
            if (is_polygon) {
                ctx.strokeStyle = 'red';
                drawLineByPolygon(ctx, px0, py0, px1, py1, true);
            } else {
                ctx.strokeStyle = 'green';
                drawLine(ctx, px0, py0, px1, py1);
            }

            // 次のアニメーションフレームを要求する
            if (anime)
                anime = window.requestAnimationFrame(render);
        };

        // アニメーションを開始する
        anime = window.requestAnimationFrame(render);
    </script>
</body>
</html>